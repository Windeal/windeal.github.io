<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>同步异步与阻塞非阻塞 &mdash; Windeal's Home</title>
  <meta name="author" content="Windeal">






  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="/favicon.png" rel="icon">

  <link href="/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">Windeal's Home</a></h1>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
</ul>


<ul class="main-navigation">
    <li><a href="/">我的博客</a></li>
    <li><a href="/categories.html">分类目录</a></li>
    <li><a href="/pages/aboutme.html">关于博主</a></li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">同步异步与阻塞非阻塞</h1>
    <p class="meta">
<time datetime="2018-08-03T19:00:44+08:00" pubdate>五 03 八月 2018</time>    </p>
</header>

  <div class="entry-content"><h2>同步异步与阻塞非阻塞</h2>
<p>标题有点简单粗暴，直接用了本文要介绍的几个概念。本来想取个高大上一点的标题，但是感觉主题不那么明了。</p>
<p>好，废话不多说，进入正题。</p>
<p>如果你是个研发，同步、异步、阻塞、非阻塞（还有IO多路复用）这些概念应该不陌生了。但是很多人却没有真正搞懂他们的含义，甚至经常把他们混淆了。</p>
<p>先上几个<strong>错误</strong>的表达提提神：</p>
<ol>
<li>非阻塞IO模型是异步IO。</li>
<li>IO多路复用模型是异步IO。</li>
</ol>
<p>第一个表达，“非阻塞IO模型是异步IO” 的说法是错误的，在UNP一书中有介绍，那么“非阻塞IO模型是同步IO模型”正确么？从《Unix网络编程》6.2节中的描述来看，是正确的。但我认为不够准确，或者说容易产生误解。UNP英文版中说的是“blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous”， 但UNP的中文版翻译成“非阻塞I/O模型是同步I/O模型”，我觉得翻译成“基于同步I/O的模型”，或者直接说它是同步的更好一点 。</p>
<p>先说下本文的主要观点：</p>
<ol>
<li><strong>讨论同步、异步、阻塞、非阻塞这些概念的时候，要先确定讨论范围。</strong>
先确定要讨论的是IO模型，还是IO操作，又或是在讨论线程的安全机制。讨论的范围不同，这些概念的含义也会发生变化。</li>
<li><strong>异步和非阻塞的区别主要在于是否需要等待获取对方状态后再返回。</strong></li>
</ol>
<h2>IO 操作</h2>
<p>关于IO操作，</p>
<p>首先说下阻塞与非阻塞的概念：</p>
<p>IO操作的完成往往是需要一定条件的，比如等待可读、可写的，也就是说IO操作很可能是没办法立即完成的。那么，如果在IO操作没办法立即完成时，不继续往下执行而是等待其完成，则该操作是阻塞的。如果我们不等待，则认为其实非阻塞的。</p>
<p>在Unix网络编程中，可以通过fcntl或者ioctl将socket套接字设置为非阻塞模式，该套接字字上的操作就会编程非阻塞IO操作。</p>
<p>再来讨论下同步与异步的概念：</p>
<p>同步操作和异步操作这样的表达其实也不太贴切，其实在IO操作中，他们更多是用来描述调用在何时返回。在man aio_read是这样描述异步（操作）的：</p>
<blockquote>
<p>The “asynchronous” means that this call returns as soon as the request has been enqueued; the read may or may not have completed when the call returns.</p>
</blockquote>
<p>看起来跟非阻塞IO操作的概念没什么不同，其实不然。异步IO操作是：只要把request加入到队列中就返回。和非阻塞IO操作不同的是，异步操作连描述符是否准备好也不需要去检查。也就是说，异步IO操作返回的时候，可能还不知道描述符准备好了没；而非阻塞操作返回时，最少我们可以通过返回值判断其是否处于可读、可写等状态。</p>
<p>同步IO操作和异步IO操作是相对而言的。</p>
<p>从上面的介绍可以得出：</p>
<p><strong>如果一个IO操作是异步操作，那他一定是非阻塞的。但是如果非阻塞操作却未必是异步IO操作。</strong></p>
<p>实际上异步IO操作仅有少数API支持（如aio_read，aio_fsync等aio_xxx形式）。我们通常使用的网络IO操作，基本上都是同步IO操作，不管它是阻塞的还是非阻塞的。</p>
<h2>IO模型</h2>
<p>关于IO模型，UNP 6.2节 有列举了常见的五中IO模型。</p>
<ul>
<li>阻塞I/O模型</li>
<li>非阻塞I/O模型</li>
<li>I/O多路复用模型</li>
<li>信号驱动I/O模型</li>
<li>异步I/O模型</li>
</ul>
<p>关于这五种模型各自的含义，UNP中有比较详细的描述了。</p>
<p>这里要注意，讨论的范围是模型，而不是IO操作。</p>
<p>实际上UNP也有明确阐述了：前面四种模型是都是同步，最后一种模型是异步的。不过UNP里面给出的原因我是有点疑问的（望大佬解疑）：</p>
<blockquote>
<p>POSIX defines these two terms as follows:
A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.
An asynchronous I/O operation does not cause the requesting process to be blocked.
Using these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.</p>
</blockquote>
<p>这里给出的前四种模型是同步的原因是because the actual I/O operation (recvfrom) blocks the process，并且举例了recvfrom。 如果根据前面给出的POSIX定义来看，表述应该是没问题的。关键点就在POSIX里面的定义表述中使用的block不太贴切。跟我前面引用的man aio_read的表述有些诧异。我认为”causes the requesting process to be blocked “中的block和我们理解的阻塞是不一致的。</p>
<h2>进程同步与线程同步</h2>
<p>谈到（并发）服务器编程时，经常会听到进程同步，线程同步等概念。这里的同步和同步IO中的同步是较大区别的。</p>
<h3>进程同步</h3>
<p>临界资源（临界区）： 一次只能允许一个进程使用的共享资源</p>
<p>进程同步：为完成某种任务而建立的多个进程需要协调它们的工作流程，以保证对临界资源的有序访问。确保不会互相干扰。</p>
<p>进程同步的手段就是进程间通信。关于进程间通信APUE等书上都讲得很清楚了，不再累述。</p>
<h3>线程同步</h3>
<p>多线程编程时，经常会提到线程同步，那么什么是线程同步？</p>
<p>线程同步的概念和进程同步有点类似。主要差别在于其“临界资源”不同。</p>
<p>我们说进程是资源分配的基本单位，也就是说多线程会共享一些资源（内存），这些资源就是线程同步的“临界资源”。</p>
<p>线程同步一般是通过加锁保护实现。线程同步需要保证同一块内存同一个时间内只有一个写用户。</p>
<h2>异步编程</h2>
<p>做后台开发的时候，经常还会谈到异步编程。这里异步跟前面的异步IO不是一个维度的概念。</p>
<p>异步编程的概念是比较模糊的。异步编程跟进程同步、线程同步有点关系，或者说异步编程实现进程同步和线程同步的一种编程思想。在编程时，考虑了（实现了）进程同步和线程同步，就可以认为是异步编程。</p>
<h2>总结</h2>
<p>前面根据概念的的讨论范围，分别介绍了与同步、异步、阻塞、非阻塞等相关的概念。其实他们也是有共通点的。</p>
<p><strong>同步和异步关注的是消息的通信机制。</strong>
异步就是，我告诉你要做什么（request），至于现在能不能做，什么时候做，我并不关心，通知下发了（enqueue）就返回。反之则是同步。</p>
<p><strong>阻塞和非阻塞关注的是最终结果是否返回了。</strong>
非阻塞就是：我告诉你我要做什么，如果现在能做，那就做完再返回；如果现在还做不了，你也给我个信儿，跟我说这事儿还做不了。</p></div>
    <footer>
<!--上一篇 下一篇-->
 <ul>
     <li>
         <a href="/update_gcc_to_support_cpp11.html">上一篇：gcc升级的简单方法</a>
     </li>
     <li>
         <a href="/kernel_mode_user_mode_fileio.html"> 下一篇：内核态与用户态、系统调用与库函数、文件IO与标准IO等概念小结</a>
     </li>
</ul> <!--上一篇 下一篇-->
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        windealli
    </span>
  </span>
<time datetime="2018-08-03T19:00:44+08:00" pubdate>五 03 八月 2018</time>  <span class="categories">
    <a class='category' href='/category/background.html'>background</a>
  </span>
  <span class="categories">
    <a class="category" href="/tag/yi-bu.html">异步</a>,    <a class="category" href="/tag/tong-bu.html">同步</a>,    <a class="category" href="/tag/zu-sai.html">阻塞</a>  </span>
</p><div class="sharing">
</div>	</footer>
  </article>


</div>
<aside class="sidebar">

  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="/kernel_mode_user_mode_fileio.html">内核态与用户态、系统调用与库函数、文件IO与标准IO等概念小结</a>
      </li>
      <li class="post">
          <a href="/sync_async_nonblock.html">同步异步与阻塞非阻塞</a>
      </li>
      <li class="post">
          <a href="/update_gcc_to_support_cpp11.html">gcc升级的简单方法</a>
      </li>
      <li class="post">
          <a href="/use_curl_to_test_http2.html">使用curl进行http2测试</a>
      </li>
      <li class="post">
          <a href="/brief_intro_htt2.html">HTTP2 入门</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
<li><a href="/category/background.html">后台开发</a> (2)<br> </li>  
<li><a href="/category/protocol.html">协议</a> (3)<br> </li>  
<li><a href="/category/tools.html">工具与环境</a> (1)<br> </li>  
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
<style>
ul.tagcloud {
  list-style: none;
    padding: 0;
}

ul.tagcloud li {
    display: inline-block;
}

li.tag-1 {
    font-size: 150%;
}

li.tag-2 {
    font-size: 120%;
}

...

ul.tagcloud .list-group-item <span>.badge {
    background-color: grey;
    color: white;
}
</style>

<ul class="tagcloud">
</ul>
  </section>


</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2017&ndash;2018  Windeal &mdash;
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="/theme/js/modernizr-2.0.js"></script>
  <script src="/theme/js/ender.js"></script>
  <script src="/theme/js/octopress.js" type="text/javascript"></script>
<!--自动推送网站链接 给百度-->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cec6991a70bb6ec4201ff2468576844a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>