Title: 内核态与用户态、系统调用与库函数、文件IO与标准IO等概念小结
Date: 2018-8-7 20:03:39
Modified: 2018-8-7 20:03:45
Category: background
Tags: 内核态、系统调用、文件IO
Slug: kernel_mode_user_mode_fileio
Authors: windealli
Summary: 内核态与用户态，其实指的是程序运行的特权级别。内核态相当于拥有系统最高的访问权限，它几乎可以访问所有的外围设备，所有的内存数据。用户态具有较低的权限，只能访问用户空间的数据。


## 内核态与用户态
### 什么是内核态和用户态
所谓内核态与用户态，其实指的是程序运行的特权级别。

> intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。
>
> Linux使用了Ring3级别运行用户态，Ring0作为 内核态。 

#### 为什么会有内核态和用户态：
为了约束程序的访问能力。使程序不能随意操作外围设备、或其他程序的数据。从而避免发生系统错误，甚至崩溃。

#### 用户空间和内核空间
用户空间和内核空间用于描述内存空间。

进程运行时与操作系统共同占有内存。其中一部分内存存放操作系统的数据（内核空间），一部分内存存放进程自身的数据（用户空间）。进程访问操作系统数据时需要先获取权限。（以32bit系统为例，地址较高的1G内存空间作为内核空间，地址较低的3G内存空间作为用户空间。）

#### 内核态和用户态分别能做什么？
内核态相当于拥有系统最高的访问权限，它几乎可以访问所有的外围设备，所有的内存数据。
用户态具有较低的权限，只能访问用户空间的数据。

#### 内核态和用户态的切换

进程主要通过两种方式从用户态切换到内核态

1. 系统调用（软中断）
2. 硬中断。

内核态和用户态都有自己的上下文环境，用户态运行与进程上下文，内核态运行与中断上下文。
用户态切换到内核态是需要保存上下文环境，因此内核态和用户态的切换是有开销的，不要随意切换。


## 系统调用和库函数

库函数工作在用户态，系统调用工作在内核态。

操作系统都会提供一些服务用以访问/操作设备等，操作系统会为这些服务提供接口。这些接口就是系统调用 。用户态程序通过调用系统调用可以切换到内核态，访问用户空间（那部分内存）以外的数据，操作外围设备等。

不同的操作系统提供的系统调用会有所差异。

Unix为每个系统调用在标准C库中设置一个具有同样名字的函数 。 一般我们是称这些函数为系统调用。（如标准C库中有函数write(), write()函数直接使用write系统调用相应的内核服务）。 所以一般说write()，指的不是write()这个函数，而是系统调用write。

标准C库，或是其他库会定义一些函数，这些函数称之为库函数。很多库函数是跨平台的。虽然有些库函数最终会调用系统调用，但不少库函数会根据具体的操作系统选用响应的系统调用接口。

有些库函数仅仅是操作内存，不访问硬盘等外围设备的数据，因此最终并不会调用系统带哦用。即：并不是所有的库函数最终都要使用系统调用的， 如：strcpy、atoi等。

## 文件IO与标准IO

用户态是不能访问硬盘、键盘、终端这些外围（虚拟）设备的，因此这些设备的IO操作需要切换到内核态。

下面是一个简单的程序从硬盘上的文件读取数据的流程：

```
1. 程序通过系统调用（如read）通知内核要执行某个文件的读操作，
2. 切换到内核态（这里需要把文件的路径等信息用户空间拷贝到内核空间）
3. 系统调用（运行在内核态）读取文件内容。
4. 切换回用户态（这个过程包含了把读取到的内容拷贝到用户空间的动作）
5. 程序读写用户空间的数据
```

在这个过程中，用户态和内核态的切换是有一定开销的。

### 缓冲区

在实际的程序中，经常出现如：频繁读写某个文件的动作。如写日志，每次写一行，大频率地写。按照前面的流程，就可能出现大频率的切换到内核态，从而产生较大开销。

为了节省开销，可以在用户态创建一个缓冲区，在程序需要些日志的时候，先把要写的内容保存在缓冲区，等到缓冲器满的时候（或者手动fflush的时候）在切换到内核态，把日志内容真正写到磁盘上的文件。

### 文件IO和标准IO

+ 文件IO是不带缓冲的——open、close、read、write都是文件IO
+ 标准IO是带缓冲的——常见的函数有fopen、fclose、fread、fwite、fgetc等。

标准IO的效率是比较高的，因而没有特殊需求的话，一般IO操作会选用带缓冲的标准IO。



#### 文件IO与标准IO的应用场景——多线程日志系统为例

在多线程日志系统中，每个线程打开一个日志文件的描述符。

如果使用带缓冲的IO，最终可能导致日志的顺序发生错乱，可能影响阅读。因此如果对多线程的日志顺序有要求的话，可能需要使用不带缓冲的IO。

另一方面，在测试中发现，使用标准IO时，每次调用write的数据并不一定都是多次完整的fwrite的数据。可能会有一些fwrite的数据被分为两次write。举个例子，每次调用fwrite写100个字节的数据，而缓冲区为550个字节，那么第6次fwrite的数据可能就被截断分成两次write。（这是我在centOS7.2上的测试结论，目前不清楚是否可以配置在fwrite写缓冲之前先判断缓冲区剩余空间是否充足，不足时先调用write，再把完整的fwrite数据写入缓冲）。（就刚刚那个例子来说，就是不知道是否可以配置，在第6次fwrite写缓冲之前先write前面的500字节）。





